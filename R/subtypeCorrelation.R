########################
## Benjamin Haibe-Kains
## All rights Reserved
## September 1, 2013
########################


`subtypeCorrelation` <- 
function (eset, sig, plot=TRUE, method=c("pearson", "spearman", "kendall"), weighted=TRUE, condensed=TRUE, resdir="cache", nthread=1, ...) {
  ## assess (weighted) correlation between gene expression with respect to subtypes
  #
  # Arga:
  #   eset: an expressionSet object
  #   geneid: vector of Entrez Gene IDs. If missing, all genes will be considered.
  #   plot: should the correlation heatmap be plotted?
  #   method: method for correlation
  #   resdir
  #   nthread:
  #   ...: parameters to be passed to sigScore
  #
  # Returns
  #   list containing p-values for comparisons
  #   Kruskal-Wallist to test whether the expression of the genes(s) of interest is dependent on the molecular subtypes
  #   pairwise wilcoxon rank sum test p-values, is the expression of the gene(s) of interest higher in the subtype in rows compared to the subtype in column?
  
  if (class(eset) != "ExpressionSet") {
    stop("Handling list of expressionSet objects is not implemented yet")
  }
  
  if (missing(sig)) {
    sig <- as.list(rownames(Biobase::fData(eset)[ , "ENTREZID"]))
    ## assign gene symbol as signature names
    gsymb <- Biobase::fData(eset)[ , "SYMBOL"]
    gsymb[is.na(gsymb)] <- paste("ENTREZID", Biobase::fData(eset)[is.na(gsymb), "ENTREZID"], sep=".")
    names(sig) <- gsymb
  }
  if (!is.list(sig) || (is.list(sig) && is.data.frame(sig))) {
    sig <- list("SIG"=sig)
  }
  if (is.null(names(sig))) {
    names(sig) <- paste("SIG", 1:length(sig), sep=".")
  }
  
  if (!file.exists(file.path(resdir))) { dir.create(file.path(resdir), showWarnings=FALSE, recursive=TRUE) }
  
  ## for a single expressionSet object
  
  ## extract subtypes
  sbts <- getSubtype(eset=eset, method="class")
  if (sum(table(sbts) > 3) < 2) {
    warning("Not enough tumors in each subtype")
    return(NULL)
  }
  if (!weighted) {
    sbts.proba <- getSubtype(eset=eset, method="crisp")
  } else {
    sbts.proba <- getSubtype(eset=eset, method="fuzzy")  
  }
  sbts.proba <- cbind("Global"=1, sbts.proba)
  sbts.crisp <- getSubtype(eset=eset, method="crisp")
  sbts.crisp <- cbind("Global"=1, sbts.crisp)
  sbtu <- colnames(sbts.proba)
  
  ## build matrix of signature scores in parallel
  splitix <- parallel::splitIndices(nx=length(sig), ncl=nthread)
  splitix <- splitix[sapply(splitix, length) > 0]
  mcres <- parallel::mclapply(splitix, function(x, sig, eset, ...) {
    res <- sigScore(eset=eset, sig=sig[[x]], ...)
    return (res)
  }, sig=sig, eset=eset, ...)
  expr <- t(do.call(cbind, mcres))
  colnames(expr) <- names(sig)
    
    
  ## compute subtype-specific pairwise correlation across query genes
  
  ## slow code
  # if (method == "spearman") {
  #   expr <- t(apply(expr, 1, rank))
  # }
  # pairs <- t(combn(1:length(gid), 2, simplify=TRUE))
  # splitix <- parallel::splitIndices(nx=nrow(pairs), ncl=nthread)
  # splitix <- splitix[sapply(splitix, length) > 0]
  # mcres <- parallel::mclapply(splitix, function(x, ...) {    
  #   res <- apply(pairs[x, , drop=FALSE], 1, function (x, ...) {
  #     res <- apply(sbts.proba, 2, function (w, x, expr) {
  #       return (wcor(d=t(expr[x, , drop=FALSE]), w=w))
  #     }, x=x, expr=expr)
  #     return (res)
  #   })
  #   return (res)
  # }, expr=expr, sbts.proba=sbts.proba)
  # res <- t(do.call(cbind, mcres))
  # rr <- unlist(apply(res, 2, function (x, y, gid) {
  #   rr <- matrix(NA, nrow=length(gid), ncol=length(gid), dimnames=list(gid, gid))
  #   rr[y] <- x
  #   rr[y[ , 2:1]] <- x
  #   diag(rr) <- 1
  #   return (list(rr))
  # }, y=pairs, gid), recursive=FALSE)

  ## using mRMRe
  nn <- mRMRe::get.thread.count()
  mRMRe::set.thread.count(nthread)
  rr <- unlist(apply(sbts.proba, 2, function (w, expr, method) {
    expr <- mRMRe::mRMR.data(data=data.frame(t(expr)), weights=w)
    cor.genes <- mRMRe::mim(object=expr, continuous_estimator=method, method="cor")
    return (list(cor.genes))
  }, expr=expr, method=method), recursive=FALSE)
  mRMRe::set.thread.count(nn)
  
  dd <- lapply(rr, function (x, glabel) {
    dd <- data.frame(x)
    dimnames(dd) <- list(glabel[rownames(x)], glabel[colnames(x)])
    return (dd)
  }, glabel=olnames(expr))
  if (condensed) {
    WriteXLS::WriteXLS(x="dd", ExcelFileName=file.path(resdir, sprintf("subtype_correlation_%s.xls", method)), AdjWidth=FALSE, BoldHeaderRow=FALSE, row.names=TRUE, col.names=TRUE, FreezeRow=1, FreezeCol=1)
  } else {
    mapply(function(x, y, method, resdir) {
       WriteXLS::WriteXLS("x", ExcelFileName=file.path(resdir, sprintf("subtype_correlation_%s_%s.xls", method, y)), AdjWidth=FALSE, BoldHeaderRow=FALSE, row.names=TRUE, col.names=TRUE, FreezeRow=1, FreezeCol=1)
     }, x=dd, y=names(dd), method=method, resdir=resdir)
  }
  return (rr)
}


